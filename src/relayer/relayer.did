type CrossChainOrderDto = record {
  maker : text;
  makingAmount : text;
  salt : text;
  makerAsset : text;
  makerTraits : text;
  takerAsset : text;
  takingAmount : text;
  receiver : text;
};
type FusionError = variant {
  TokenAddressInvalid;
  InvalidAmount;
  OrderNotPending;
  SystemError;
  OrderNotFound;
  OrderExpired;
  Unauthorized;
  InvalidSalt;
  InvalidSecretHash;
  InvalidEIP712Signature;
};
type Order = record {
  id : text;
  fills : vec text;
  auction_start_date : nat64;
  status : OrderStatus;
  secret_hashes : vec text;
  signature : text;
  src_chain_id : nat64;
  maker_asset : text;
  hashlock : text;
  taking_amount : text;
  is_maker_contract : bool;
  making_amount : text;
  maker_eth_address : text;
  salt : text;
  deadline : nat64;
  created_at : nat64;
  remaining_maker_amount : text;
  dst_chain_id : nat64;
  auction_end_date : nat64;
  maker_traits : text;
  taker_asset : text;
  maker_balance : text;
  quote_id : text;
  maker_allowance : text;
  expires_at : nat64;
  maker_icp_principal : principal;
  extension : text;
};
type OrderStatus = variant { Failed; Accepted; Cancelled; Completed; Pending };
type Result = variant { Ok : Order; Err : FusionError };
type Result_1 = variant { Ok : bool; Err : FusionError };
type Result_2 = variant { Ok : vec text; Err : FusionError };
type Result_3 = variant { Ok : text; Err : FusionError };
service : {
  fusion_plus_order_escrow : (text, nat64) -> (Result) query;
  fusion_plus_order_ready_to_accept_secret_fills : (text) -> (Result_1) query;
  fusion_plus_order_secrets : (text) -> (Result_2) query;
  fusion_plus_order_status : (text) -> (Result) query;
  fusion_plus_orders_active : () -> (vec Order) query;
  fusion_plus_relayer_submit : (
      CrossChainOrderDto,
      nat64,
      text,
      text,
      text,
      vec text,
    ) -> (Result_3);
}
